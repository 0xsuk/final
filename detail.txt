- plays 2 stems at the same time(same for play, cue, loop)
- different effect sets for 2 stems (different for eq, filter)

- support realtime stem separation using demucs
- support ahead of time separated track loading.
  - option 1: load audio file that contains stems as different channels
    - less storage
    - no standalone acapella, instrument file.
  - option 2: load audio files, each for each stem.
    - triple storage
    - standalone acapella/inst
  - (Choice)option 3 (1 and 2): Choose option 1 or 2 according to the file name


- libfinyl should focus on track controlling and writing to alsa: cue, loop, volume, effect, eq. Effects are the only part that user might want to define on their own. So, provide callback:
## user
int left_nob_degree = 0.6;
void your_function(*sample_buffer, period_size) {
     //like, multiply samples by nob_degree
}
finyl_callback(your_function, left_track, all_stems);
## finyl
function_chain[]
void finyl_callback(some_function, left_or_what, stem) {
     //build function chain 
     function_chain.add(some_function)
}
- client reads midi, calls api, do visualization. can define custom effects here
# user
finyl_set_track_callback([lambda (*pcm) get pointer to pcm here?])
finyl_set_loop_callback()
finyl_jump_callback(handle_loop_or_, ) 


- defs for callbacks setting function (finyl-*) are in finyl.h, others in finyl_dev.h




- everything is effect: filter, eq, reverb, echo, volume
- some effects need to accumulate samples to buffer: reverb, echo
- some effects just work with single sample: filter, eq, volume
- effects ON/OFF are handled by client in callback.
- some effects should be handled later than other. Echos and Reverbs should be handled later than volume, otherwise if volume goes 0, echos and reverbs will disappear right away.

- what about vinyl break?
  - it has to modify the position, before effect?
  - then effect gets sample at that position, do stuff  
- same for start stop


- so what effect and position_changer are doing can be abstracted.



